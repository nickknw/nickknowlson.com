---
layout: project
date: 2012-02-05
title: Exercises from Seven Languages In Seven Weeks
languages: Ruby, Io, Prolog, Scala, Erlang, Clojure, Haskell
summary: Working through the exercises from Seven Languages In Seven Weeks.
github: seven-languages-in-seven-weeks
thumbnail: /img/projects/seven-languages/thumb.png
screenshots: 
videos:
---

As I work through the exercises in the book [*Seven Languages in Seven
Weeks*](http://www.pragprog.com/titles/btlang/seven-languages-in-seven-weeks) by
Bruce Tate, I will keep this page updated with my progress. Each day will be
represented by a separate blog post.

Why am I doing this? Many reasons! I want to widen my horizons, to generalize before I
specialize. I want to learn how to learn and practice getting good at it. I want
to separate the essence of programming from the notation. I want to [live with the
masters](http://www.cs.uni.edu/~wallingf/blog/archives/monthly/2012-09.html#e2012-09-05T17_24_37.htm) and learn from them. Also, it's a ton of fun!

<h3>Week 1: Ruby</h3>

Impressions from Day 1 post:
<blockquote>
Out of the seven languages in this book, Ruby is the one I was most familiar with previously. It made for an easy start, and gave me a bit of momentum before I started to tackle languages like Prolog.
</blockquote>

* [Day 1](/blog/2011/11/27/seven-languages-week-1-day-1/) - string manipulation,
  looping  
* [Day 2](/blog/2011/12/04/seven-languages-week-1-day-2/) - collections,
  closures, classes, modules  
* [Day 3](/blog/2011/12/15/seven-languages-week-1-day-3/) - open classes,
  method\_missing, mixins  

<h3>Week 2: Io</h3>

Impressions from Day 1 post:
<blockquote>
Syntactically, Io is a very very lightweight language, evocative of lisps in its regularity and minimalism. It provides a nice contrast with the previous chapter on Ruby. Ruby’s definition of simple code is something like “The more an expression reads like a (succinct) explanation of its intent, the better” whereas Io’s definition of simple code is something like “The less extraneous syntax that is needed to represent an expression, the better”.
</blockquote>

* [Day 1](/blog/2011/12/18/seven-languages-week-2-day-1/) - syntax, slots,
  prototypes  
* [Day 2](/blog/2012/01/11/seven-languages-week-2-day-2/) - conditionals, loops,
  operators, messages, reflection  

  * [Transposing a matrix in Io](/blog/2011/12/30/transposing-a-matrix-in-io/) -
    deconstruction of a pretty solution  
* [Day 3](/blog/2012/01/16/seven-languages-week-2-day-3/) - metaprogramming,
  internal DSLs, concurrency  

<h3>Week 3: Prolog</h3>
Impressions from Day 1 post:
<blockquote>
Despite all this, during the course of Week 3 I have been convinced that logic programming can be extremely powerful. If you know how to define a problem in terms that Prolog understands, then you can write a program that solves a problem without having the slightest idea of how to actually solve it (a good example is Sudoku, which shows up in Day 3). Logic languages are the closest I have seen to the unattainable ideal of ‘writing a program that will look at the problem and write a program to solve it for you’.
</blockquote>

* [Day 1](/blog/2012/02/05/seven-languages-week-3-day-1/) - facts, rules,
  queries  
* [Day 2](/blog/2012/07/17/seven-languages-week-3-day-2/) - lists and pattern
  matching with them, contrasting logic programming with other paradigms  
* [Day 3](/blog/2012/08/06/seven-languages-week-3-day-3/) - datalog, constraint
  programming, other logic languages, logic libraries  

<h3>Week 4: Scala</h3>
Impressions from Day 1 post:
<blockquote>
The beauty of Scala (in my eyes) is its flexibility and practicality.   It
pushes you towards immutability and is capable of very succinct functional code,
but it also has that mutable imperative escape hatch, and a good set of tools
for working with problems that suit code like that. It will let you write in the 
style that is most appropriate for the problem you are trying to solve.
</blockquote>

* [Day 1](/blog/2013/03/28/seven-languages-week-4-day-1/) - syntax, object oriented features
* [Day 2](/blog/2013/04/10/seven-languages-week-4-day-2/) - functional programming, collections, idea of emptiness
